use std::mem;


struct Counter {
    counter: Vec<usize>,
    last_rollover: usize,
    capacity: usize,
}


impl Counter {
    fn new(num_plates: usize) -> Counter {
        let scale: usize = mem::size_of::<usize>() * 8;
        let mut real_size: usize = num_plates / scale;
        if num_plates % scale != 0 {
            real_size = real_size + 1;
        }


        let mut res: Counter = Counter {
            counter: Vec::with_capacity(real_size),
            capacity: real_size - 1,
            last_rollover: 0,
        };

        for i in 0..real_size {
            res.counter.push(0);
        }

        return res;
    }


    fn increment(&mut self) {
        let mut word_index: usize = 0;
        let mut bit_index: usize = 0;
        while word_index <= self.capacity && self.counter[self.capacity - word_index] == usize::MAX {
            self.counter[self.capacity - word_index] = 0;
            word_index = word_index + 1;
        }
        self.counter[self.capacity - word_index] = self.counter[self.capacity - word_index] + 1;

        while bit_index < mem::size_of::<usize>() * 8 && (self.counter[self.capacity - word_index] >> bit_index) & 0x01 == 0 {
            bit_index = bit_index + 1;
        }
        self.last_rollover = word_index * mem::size_of::<usize>()  * 8 + bit_index;
    }


    fn which_disc(&self) -> usize {
        return self.last_rollover;
    }
}


enum Disc {
    Disc {
        index: usize,
        next: Box<Disc>,
    },
    Plate,
}


struct Tower {
    name: String,
    stack: Box<Disc>,
}


impl Tower {
    fn empty(name: &str) -> Tower {
        return Tower {
            name: String::from(name),
            stack: Box::<Disc>::new(Disc::Plate),
        };
    }


    fn full(name: &str, size: usize) -> Tower {
        let mut res: Tower = Tower::empty(name);
        let mut disc: Disc;
        for i in 0..size {
            disc = Disc::Disc { index: size - (i + 1), next: Box::<Disc>::new(*res.stack) };
            *res.stack = disc;
        }
        return res;
    }


    fn push(&mut self, mut disc: Box<Disc>) {
        match *disc {
            Disc::Disc { index, ref next } => {
                next = self.stack;
                self.stack = disc;
            },
            Disc::Plate => { },
        }
    }


    fn pop(&mut self) -> Option<Box<Disc>> {
        match *self.stack {
            Disc::Disc { index, ref next } => {
                let disc: Box<Disc> = self.stack;
                self.stack = next;
                return Some(disc);
            },
            Disc::Plate => { },
        }
        return None;
    }


    fn peek(&self) -> Disc {
        return *self.stack;
    }


    fn move_to(&mut self, other: &mut Tower) {
        if !self.can_move(other) {
            println!("Error! Illegal move!");
        }
        let opt: Option<Box<Disc>> = self.pop();
        match opt {
            Some(disc) => {
                other.push(disc);
            },
            None => { },
        }
    }


    fn count(&self) -> usize {
        let disc: Box<Disc> = self.stack;
        let mut i: usize = 0;
        loop {
            match *disc {
                Disc::Disc { index, ref next } => {
                    i = i + 1;
                    disc = next;
                },
                Disc::Plate => {
                    return i;
                },
            }
        }
    }


    fn is_valid(&self) -> bool {
        let mut disc: &Disc = &*self.stack;
        loop {
            match *disc {
                Disc::Disc { index, ref next } => {
                    let smaller: usize = index;
                    match next {
                        Disc::Disc { index, ref next } => {
                            if smaller >= *index {
                                return false;
                            }
                        },
                        Disc::Plate => {
                            break;
                        }
                    }
                    disc = &**next;
                },
                Disc::Plate => {
                    break;
                },
            }
        }
        return true;
    }


    fn can_move(&self, other: &Tower) -> bool {
        match self.peek() {
            Disc::Disc { index, ref next } => {
                let smaller: usize = index;
                match other.peek() {
                    Disc::Disc { index, ref next } => {
                        return smaller < index;
                    },
                    Disc::Plate => {
                        return true;
                    }
                }
            },
            Disc::Plate => {
                return false;
            },
        }
    }
}


fn main() {

    const print_status: bool = true;
    const stack_size: usize = 3;

    let mut counter: Counter = Counter::new(stack_size);
    
    //let mut towers: [Tower; 3] = [Tower::full("A", stack_size), Tower::empty("B"), Tower::empty("C")];

    let mut a: Tower = Tower::full("A", stack_size);
    let mut b: Tower = Tower::empty("B");
    let mut c: Tower = Tower::empty("C");

    let disc: Disc;

    while c.count() < stack_size {
        if print_status {
            display_towers(&a, &b, &c);
        }

        counter.increment();

        match a.peek() {
            Disc::Disc { index, ref next } => {
                if index == counter.last_rollover {
                    if index == 0 || a.can_move(&b) {
                        a.move_to(&mut b);
                    } else {
                        a.move_to(&mut c);
                    }
                    continue;
                }
            },
            Disc::Plate => { },
        }

        match b.peek() {
            Disc::Disc { index, ref next } => {
                if index == counter.last_rollover {
                    if index == 0 || b.can_move(&c) {
                        b.move_to(&mut c);
                    } else {
                        b.move_to(&mut a);
                    }
                    continue;
                }
            },
            Disc::Plate => { },
        }

        match c.peek() {
            Disc::Disc { index, ref next } => {
                if index == counter.last_rollover {
                    if index == 0 || c.can_move(&a) {
                        c.move_to(&mut a);
                    } else {
                        c.move_to(&mut b);
                    }
                } else {
                    println!("ERROR! Next move not found! :^(");
                }
            },
            Disc::Plate => { },
        }

        /*
        for i in 0..3 {
            let (lower, higher) = towers.split_at_mut(i);
            match towers[i].peek() {
                Disc::Disc { index, next } => {
                    if index == counter.last_rollover {
                        if index == 0 || towers[i].can_move(&towers[(i + 1) % 3]) {
                            towers[i].move_to(&mut towers[(i + 1) % 3]);
                        } else {
                            towers[i].move_to(&mut towers[(i + 2) % 3]);
                        }
                    }
                },
                Disc::Plate => { },
            }
        }
        */


    }
}


fn display_towers(a: &Tower, b: &Tower, c: &Tower) {
    let mut discs: [&Disc; 3] = [&a.stack, &b.stack, &c.stack];
    let mut plates: usize;
    println!("A:              B:              C:              ");
    loop {
        plates = 0;
        match discs[0] {
            Disc::Disc { index, ref next } => {
                print!("{:>14}  ", index);
                discs[0] = &**next;
            },
            Disc:: Plate => {
                print!("                ");
                plates = plates + 1;
            },
        }
        match discs[1] {
            Disc::Disc { index, ref next } => {
                print!("{:>14}  ", index);
                discs[1] = &(*next);
            },
            Disc::Plate => {
                print!("                ");
                plates = plates + 1;
            },
        }
        match discs[2] {
            Disc::Disc { index, ref next } => {
                println!("{:>14}  ", index);
                discs[2] = &(*next);
            },
            Disc::Plate => {
                println!("                ");
                plates = plates + 1;
            },
        }
        if plates > 2 {
            return;
        }
    }
}
